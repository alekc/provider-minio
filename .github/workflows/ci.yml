name: CI

on:
  push:
    tags:
      - 'v*'
  pull_request: {}
  workflow_dispatch: {}


env:
  # Common versions
  GO_VERSION: '1.21'
  # renovate: datasource=github-releases depName=golangci/golangci-lint
  GOLANGCI_VERSION: 'v2.4.0'
  DOCKER_BUILDX_VERSION: 'v0.8.2'
  CROSSPLANE_REGORG: 'ghcr.io/${{ github.repository_owner }}'
  UPBOUND_REGORG: 'xpkg.upbound.io/alekc'

  # Common users. We can't run a step 'if secrets.XXX != ""' but we can run a
  # step 'if env.XXX != ""', so we copy these to succinctly test whether
  # credentials have been provided before trying to run steps that need them.
  UPBOUND_MARKETPLACE_PUSH_ROBOT_USR: ${{ secrets.UPBOUND_MARKETPLACE_PUSH_ROBOT_USR }}
  XPKG_MIRROR_ACCESS_ID: ${{ secrets.XPKG_MIRROR_ACCESS_ID }}

permissions:
  contents: read
  packages: write

jobs:
  detect-noop:
    runs-on: ubuntu-24.04
    outputs:
      noop: ${{ steps.noop.outputs.should_skip }}
    steps:
      - name: Detect No-op Changes
        id: noop
        uses: fkirc/skip-duplicate-actions@f75f66ce1886f00957d99748a42c724f4330bdcf # v5.3.1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          paths_ignore: '["**.md", "**.png", "**.jpg"]'
          do_not_skip: '["workflow_dispatch", "schedule", "push"]'

  report-breaking-changes:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          submodules: true

      - name: Get modified CRDs
        id: modified-crds
        uses: tj-actions/changed-files@ed68ef82c095e0d48ec87eccea555d944a631a4c # v46
        with:
          files: |
            package/crds/**
      - name: Report breaking CRD OpenAPI v3 schema changes
        if: steps.modified-crds.outputs.any_changed == 'true'
        env:
          MODIFIED_CRD_LIST: ${{ steps.modified-crds.outputs.all_changed_files }}
        run: |
          make crddiff
      - name: Report native schema version changes
        if: ${{ inputs.upjet-based-provider }}
        run: |
          make schema-version-diff

  lint:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          submodules: true

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Find the Go Build Cache
        id: go
        run: echo "cache=$(make go.cachedir)" >> $GITHUB_OUTPUT

      - name: Cache the Go Build Cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: ${{ steps.go.outputs.cache }}
          key: ${{ runner.os }}-build-lint-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-build-lint-

      - name: Cache Go Dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: .work/pkg
          key: ${{ runner.os }}-pkg-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-pkg-

      - name: Vendor Dependencies
        run: make vendor vendor.check

      # We could run 'make lint' but we prefer this action because it leaves
      # 'annotations' (i.e. it comments on PRs to point out linter violations).
      - name: Lint
        uses: golangci/golangci-lint-action@4afd733a84b1f43292c63897423277bb7f4313a9 # v8
        with:
          version: ${{ env.GOLANGCI_VERSION }}

  check-diff:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          submodules: true

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install goimports
        run: go install golang.org/x/tools/cmd/goimports

      - name: Find the Go Build Cache
        id: go
        run: echo "cache=$(make go.cachedir)" >> $GITHUB_OUTPUT

      - name: Cache the Go Build Cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: ${{ steps.go.outputs.cache }}
          key: ${{ runner.os }}-build-check-diff-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-build-check-diff-

      - name: Cache Go Dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: .work/pkg
          key: ${{ runner.os }}-pkg-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-pkg-

      - name: Vendor Dependencies
        run: make vendor vendor.check

      - name: Check Diff
        run: make patch-docs && make check-diff

  unit-tests:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          submodules: true

      - name: Fetch History
        run: git fetch --prune --unshallow

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Find the Go Build Cache
        id: go
        run: echo "cache=$(make go.cachedir)" >> $GITHUB_OUTPUT

      - name: Cache the Go Build Cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: ${{ steps.go.outputs.cache }}
          key: ${{ runner.os }}-build-unit-tests-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-build-unit-tests-

      - name: Cache Go Dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: .work/pkg
          key: ${{ runner.os }}-pkg-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-pkg-

      - name: Vendor Dependencies
        run: make vendor vendor.check

      - name: Run Unit Tests
        run: make -j2 test

      - name: Publish Unit Test Coverage
        uses: codecov/codecov-action@5a1091511ad55cbe89839c7260b706298ca349f7 # v5
        with:
          flags: unittests
          file: _output/tests/linux_amd64/coverage.txt

  e2e:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          submodules: true

      - name: Fetch History
        run: git fetch --prune --unshallow

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Find the Go Build Cache
        id: go
        run: echo "cache=$(make go.cachedir)" >> $GITHUB_OUTPUT

      - name: Cache the Go Build Cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: ${{ steps.go.outputs.cache }}
          key: ${{ runner.os }}-build-unit-tests-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-build-unit-tests-

      - name: Cache Go Dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: .work/pkg
          key: ${{ runner.os }}-pkg-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-pkg-

      - name: Vendor Dependencies
        run: make vendor vendor.check

      - name: Deploying locally built provider package
        run: make custom-e2e

  publish-artifacts:
    runs-on: ubuntu-24.04
    needs:
      - detect-noop
      - report-breaking-changes
      - lint
      - check-diff
      - unit-tests
      - e2e
    if: needs.detect-noop.outputs.noop != 'true'

    steps:
      - name: Setup QEMU
        uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392 # v3
        with:
          platforms: all

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3
        with:
          version: ${{ env.DOCKER_BUILDX_VERSION }}
          install: true

      - name: Login to GHCR using PAT
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5
        with:
          submodules: true

      - name: Fetch History
        run: git fetch --prune --unshallow

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Find the Go Build Cache
        id: go
        run: echo "cache=$(make go.cachedir)" >> $GITHUB_OUTPUT

      - name: Cache the Go Build Cache
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: ${{ steps.go.outputs.cache }}
          key: ${{ runner.os }}-build-publish-artifacts-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-build-publish-artifacts-

      - name: Cache Go Dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: .work/pkg
          key: ${{ runner.os }}-pkg-${{ hashFiles('**/go.sum') }}
          restore-keys: ${{ runner.os }}-pkg-

      - name: Vendor Dependencies
        run: make vendor vendor.check

      - name: Build Artifacts
        run: make -j2 build.all
        env:
          # We're using docker buildx, which doesn't actually load the images it
          # builds by default. Specifying --load does so.
          BUILD_ARGS: "--load"

      - name: Upload Artifacts to GitHub
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: output
          path: _output/**

      - name: Generate metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.CROSSPLANE_REGORG }}/${{ github.event.repository.name }}
          tags: |
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}

#      - name: Publish Artifacts
#        run: make publish BRANCH_NAME=main
#
      - name: Publish Artifacts to GitHub
        id: publish
        run: |-
          make -j2 XPKG_REG_ORGS="${{ env.CROSSPLANE_REGORG }}" XPKG_REG_ORGS_NO_PROMOTE="${{ env.CROSSPLANE_REGORG }}" BRANCH_NAME="main" ${{ inputs.version != '' && format('VERSION={0}', inputs.version) || '' }} publish
          # Capture the VERSION used for publishing
          echo "published_version=$(make VERSION=${{ inputs.version != '' && inputs.version || '' }} version 2>/dev/null | grep VERSION= | cut -d= -f2 || echo '')" >> $GITHUB_OUTPUT

      - name: Tag and Push Published Image with Metadata Tags
        run: |-
          IMAGE_NAME="${{ env.CROSSPLANE_REGORG }}/${{ github.event.repository.name }}"
          # Get the published version - try inputs.version first, then determine from git
          if [ -n "${{ inputs.version }}" ]; then
            PUBLISHED_TAG="${{ inputs.version }}"
          else
            # Extract version from git (matching Makefile logic)
            if [ -z "$(git tag)" ]; then
              PUBLISHED_TAG="v0.0.0-$(git rev-list HEAD --count)-g$(git describe --dirty --always | sed 's/-/./2' | sed 's/-/./2' | sed 's/-/./2')"
            else
              PUBLISHED_TAG=$(git describe --dirty --always --tags | sed 's|.*/||' | sed 's/-/./2' | sed 's/-/./2' | sed 's/-/./2')
            fi
          fi
          SOURCE_IMAGE="${IMAGE_NAME}:${PUBLISHED_TAG}"
          
          # Extract tags from metadata output and push each one
          METADATA_TAGS="${{ steps.meta.outputs.tags }}"
          if [ -n "${METADATA_TAGS}" ]; then
            echo "Source image: ${SOURCE_IMAGE}"
            echo "Metadata tags: ${METADATA_TAGS}"
            for TAG_STRING in ${METADATA_TAGS}; do
              # TAG_STRING format: registry/org/repo:tag
              # Extract just the tag part (after the colon)
              TAG=$(echo "${TAG_STRING}" | cut -d: -f2)
              TARGET_IMAGE="${IMAGE_NAME}:${TAG}"
              if [ "${TARGET_IMAGE}" != "${SOURCE_IMAGE}" ]; then
                echo "Creating tag ${TARGET_IMAGE} from ${SOURCE_IMAGE}"
                docker buildx imagetools create -t "${TARGET_IMAGE}" "${SOURCE_IMAGE}"
              fi
            done
          else
            echo "No metadata tags found to apply"
          fi

      - name: Login to upbound
        if: env.XPKG_MIRROR_ACCESS_ID != '' && startsWith(github.ref, 'refs/tags/')
        run: |
          ./.cache/tools/linux_x86_64/up-v0.40.0-0.rc.3 login --token=${{ secrets.XPKG_MIRROR_TOKEN }}
          ./.cache/tools/linux_x86_64/up-v0.40.0-0.rc.3 robot list

      - name: Publish Artifacts to Upbound
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          TAG_NAME="${GITHUB_REF#refs/tags/}"
          make -j2 XPKG_REG_ORGS="${{ env.UPBOUND_REGORG }}" XPKG_REG_ORGS_NO_PROMOTE="${{ env.UPBOUND_REGORG }}" BRANCH_NAME="main" VERSION="$TAG_NAME" publish

      - name: Cleanup Upbound config
        if: always()
        run: rm -f ~/.up/config.json
